<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QKD: The Quantum Protocol - Gamified 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        #hud {
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.7);
        }
        .hud-element {
            backdrop-filter: blur(5px);
            background: linear-gradient(rgba(0, 25, 50, 0.5), rgba(0, 15, 30, 0.7));
            border: 1px solid rgba(0, 191, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 191, 255, 0.2) inset;
        }
        .mission-objective {
            border-left: 4px solid #00BFFF;
            transform: translateX(-150%);
            opacity: 0;
        }
        .data-bit {
            width: 35px;
            height: 45px;
            text-align: center;
            margin: 2px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 1.1rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
            background: rgba(0,0,0,0.3);
        }
        .basis-symbol {
            font-family: monospace;
            font-size: 1.5rem;
            line-height: 1;
        }
        .btn-3d {
            background: linear-gradient(145deg, #00BFFF, #1E90FF);
            border: none;
            color: white;
            padding: 1rem 2rem;
            font-size: 1.2rem;
            border-radius: 50px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 191, 255, 0.6);
        }
        .btn-3d:before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 60%);
            transform: rotate(45deg);
            transition: all 0.5s ease;
        }
        .btn-3d:hover {
            transform: scale(1.05);
            box-shadow: 0 0 35px rgba(0, 191, 255, 0.9);
        }
        .btn-3d:hover:before {
            left: 50%;
            top: 50%;
        }
        .btn-3d:disabled {
            background: #444;
            box-shadow: none;
            cursor: not-allowed;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <!-- HUD Overlay -->
    <div id="hud" class="absolute top-0 left-0 w-full h-full p-4 md:p-6 flex flex-col pointer-events-none text-cyan-300">
        <!-- Header -->
        <div class="text-center">
            <h1 class="text-3xl md:text-4xl font-bold">QKD PROTOCOL</h1>
            <p class="text-sm">CINEMATIC SIMULATION</p>
        </div>

        <!-- Mission Objective Panel -->
        <div id="mission-panel" class="absolute top-24 left-4 md:left-6 w-full max-w-md">
             <div id="mission-objective" class="mission-objective hud-element p-4 rounded-r-lg">
                 <h2 id="step-title" class="text-xl md:text-2xl font-bold text-white mb-2"></h2>
                 <p id="step-description" class="text-sm md:text-base font-light text-gray-200"></p>
             </div>
        </div>

        <!-- Data Displays -->
        <div class="absolute bottom-4 left-4 md:left-6 w-5/12 max-w-md hud-element rounded-lg p-3">
            <h3 class="text-white font-bold text-base mb-1">DR. ALICE // SENDER</h3>
            <h4 class="text-cyan-200 text-xs">SENT QUBITS [BIT/BASIS]:</h4>
            <div id="alice-data" class="flex flex-wrap mt-1 min-h-[47px]"></div>
        </div>

        <div class="absolute bottom-4 right-4 md:right-6 w-5/12 max-w-md hud-element rounded-lg p-3">
            <h3 class="text-white font-bold text-base mb-1">PATIENT BOB // RECEIVER</h3>
            <h4 class="text-cyan-200 text-xs">MEASURED QUBITS [BASIS/BIT]:</h4>
            <div id="bob-data" class="flex flex-wrap mt-1 min-h-[47px]"></div>
        </div>
        
        <!-- Final Key & Controls -->
        <div class="absolute bottom-4 left-1/2 -translate-x-1/2 flex flex-col items-center gap-4 pointer-events-auto">
             <div id="final-key-display" class="hud-element p-3 rounded-lg text-center opacity-0 transition-opacity duration-500">
                <h3 class="text-green-300 font-bold">SECURE KEY ESTABLISHED</h3>
                <div id="final-key" class="flex justify-center mt-1"></div>
             </div>
             <div id="error-rate-display" class="hud-element p-3 rounded-lg text-center hidden">
                <p class="font-bold text-red-400">COMPROMISED CHANNEL!</p>
                <p class="text-white">Error Rate: <span id="error-value">0%</span></p>
            </div>
            <div class="flex items-center bg-gray-900/50 p-2 rounded-full">
                <label for="eve-toggle" class="mr-3 text-red-400 font-bold">ACTIVATE HACKER</label>
                <input type="checkbox" id="eve-toggle" class="h-5 w-5 text-red-500 bg-gray-700 border-gray-600 rounded focus:ring-red-600">
            </div>
            <button id="start-btn" class="btn-3d font-bold">
                INITIATE PROTOCOL
            </button>
        </div>
    </div>

    <script>
        // --- SETUP ---
        let scene, camera, renderer, clock, mixer;
        let doctor, patient, eve;
        let photons = [];
        let simulationRunning = false;
        const NUM_PHOTONS = 10;
        
        const UI = {
            startBtn: document.getElementById('start-btn'),
            eveToggle: document.getElementById('eve-toggle'),
            missionObjective: document.getElementById('mission-objective'),
            stepTitle: document.getElementById('step-title'),
            stepDescription: document.getElementById('step-description'),
            aliceData: document.getElementById('alice-data'),
            bobData: document.getElementById('bob-data'),
            finalKeyDisplay: document.getElementById('final-key-display'),
            finalKey: document.getElementById('final-key'),
            errorDisplay: document.getElementById('error-rate-display'),
            errorValue: document.getElementById('error-value'),
        };

        // --- INITIALIZATION ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000510);
            scene.fog = new THREE.Fog(0x000510, 150, 400);
            
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            clock = new THREE.Clock();

            setupLighting();
            setupEnvironment();
            createModels();
            
            UI.startBtn.addEventListener('click', startSimulation);
            window.addEventListener('resize', onWindowResize);
            
            resetCamera();
            animate();
        }

        // --- SCENE & ENVIRONMENT ---
        function setupLighting() {
            scene.add(new THREE.AmbientLight(0x404080, 1));
            const spotLight = new THREE.SpotLight(0xffffff, 1);
            spotLight.position.set(0, 150, 100);
            spotLight.angle = Math.PI / 6;
            spotLight.penumbra = 0.5;
            spotLight.castShadow = true;
            scene.add(spotLight);
        }

        function setupEnvironment() {
            const grid = new THREE.GridHelper(400, 40, 0x00ffff, 0x004444);
            grid.material.opacity = 0.2;
            grid.material.transparent = true;
            scene.add(grid);
        }

        // --- 3D MODELS ---
        function createModels() {
            doctor = createDoctor({ x: -100, y: 0, z: 0 });
            patient = createPatient({ x: 100, y: 0, z: 0 });
            eve = createEveRobot({ x: 0, y: 0, z: 0 });
            eve.group.visible = false;
        }

        function createDoctor(pos) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CylinderGeometry(4, 6, 20, 8), new THREE.MeshStandardMaterial({ color: 0xeeeeee, metalness: 0.1, roughness: 0.6 }));
            const head = new THREE.Mesh(new THREE.SphereGeometry(5, 16, 12), new THREE.MeshStandardMaterial({ color: 0xdddddd }));
            head.position.y = 13;
            const visor = new THREE.Mesh(new THREE.TorusGeometry(3.5, 0.5, 4, 16, Math.PI), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
            visor.position.z = 2;
            visor.rotation.x = Math.PI / 2;
            head.add(visor);
            group.add(body, head);
            scene.add(group);
            group.position.set(pos.x, 10, pos.z);
            return { group };
        }
        
        function createPatient(pos) {
            const group = createDoctor(pos); // Similar model for simplicity
            group.group.traverse(child => {
                if(child.isMesh) child.material.color.set(0x9999ff);
            });
            return group;
        }

        function createEveRobot(pos) {
            const group = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x330000, roughness: 0.2, metalness: 0.9 });
            const body = new THREE.Mesh(new THREE.ConeGeometry(8, 20, 6), bodyMat);
            const head = new THREE.Mesh(new THREE.SphereGeometry(6, 8, 6), bodyMat);
            head.position.y = 12;
            const eye = new THREE.Mesh(new THREE.SphereGeometry(2, 16, 8), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            eye.position.z = 5;
            head.add(eye);
            group.add(body, head);
            scene.add(group);
            group.position.set(pos.x, 10, pos.z);
            return { group, eye };
        }

        function createPhoton(bit, basis) {
            const color = basis === '+' ? 0x00ffff : 0xff00ff;
            const group = new THREE.Group();
            const core = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 8), new THREE.MeshBasicMaterial({ color }));
            const shellGeo = new THREE.SphereGeometry(2, 16, 8);
            const shellMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.3 });
            const shell = new THREE.Mesh(shellGeo, shellMat);
            group.add(core, shell);
            
            const light = new THREE.PointLight(color, 2, 20);
            group.add(light);
            
            group.position.copy(doctor.group.position);
            group.position.y = 15;
            scene.add(group);
            
            return {
                group, core, shell,
                bit, basis, originalBit: bit, originalBasis: basis,
                progress: 0, intercepted: false
            };
        }
        
        // --- SIMULATION FLOW ---
        async function startSimulation() {
            if (simulationRunning) return;
            simulationRunning = true;
            UI.startBtn.disabled = true;
            UI.startBtn.textContent = "PROTOCOL RUNNING...";
            
            resetUI();
            const isEveActive = UI.eveToggle.checked;
            eve.group.visible = isEveActive;

            // Step 1: Alice prepares
            moveCamera(doctor.group.position, 50);
            await showMission("Step 1: Qubit Encoding", "Dr. Alice generates random bits and encodes them onto photons using random bases (+ or x).");
            const aliceBits = Array.from({ length: NUM_PHOTONS }, () => Math.round(Math.random()));
            const aliceBases = Array.from({ length: NUM_PHOTONS }, () => ['+', 'x'][Math.floor(Math.random() * 2)]);
            for (let i = 0; i < NUM_PHOTONS; i++) {
                photons.push(createPhoton(aliceBits[i], aliceBases[i]));
                displayData(UI.aliceData, aliceBits[i], aliceBases[i]);
                await sleep(100);
            }

            // Step 2: Transmission
            resetCamera();
            await showMission("Step 2: Quantum Transmission", "Photons travel through the quantum channel. Any observation will disturb their state.");
            await animatePhotons();
            
            // Step 3: Bob measures
            moveCamera(patient.group.position, 50);
            await showMission("Step 3: Qubit Measurement", "Patient Bob measures each photon using his own randomly chosen bases.");
            const bobBases = Array.from({ length: NUM_PHOTONS }, () => ['+', 'x'][Math.floor(Math.random() * 2)]);
            const bobBits = [];
            photons.forEach((p, i) => {
                bobBits.push(p.basis === bobBases[i] ? p.bit : Math.round(Math.random()));
                displayData(UI.bobData, bobBits[i], bobBases[i]);
            });
            await sleep(2000);

            // Step 4: Sifting
            resetCamera();
            await showMission("Step 4: Basis Reconciliation", "They publicly compare bases and discard measurements where bases did not match.");
            const aliceKey = [], bobKey = [];
            for (let i = 0; i < NUM_PHOTONS; i++) {
                if (photons[i].originalBasis === bobBases[i]) {
                    UI.aliceData.children[i].style.background = 'rgba(0, 255, 127, 0.4)';
                    UI.bobData.children[i].style.background = 'rgba(0, 255, 127, 0.4)';
                    aliceKey.push(photons[i].originalBit);
                    bobKey.push(bobBits[i]);
                } else {
                    UI.aliceData.children[i].style.background = 'rgba(255, 165, 0, 0.3)';
                    UI.bobData.children[i].style.background = 'rgba(255, 165, 0, 0.3)';
                }
                await sleep(150);
            }
            
            // Step 5: Final Check
            await showMission("Step 5: Security Check", "A sample of the keys are compared. A high error rate indicates an eavesdropper.");
            let errors = 0;
            aliceKey.forEach((bit, i) => { if (bit !== bobKey[i]) errors++; });
            const errorRate = aliceKey.length > 0 ? (errors / aliceKey.length) * 100 : 0;
            
            if (isEveActive && errorRate > 15) {
                UI.errorDisplay.style.display = 'block';
                UI.errorValue.textContent = `${errorRate.toFixed(1)}%`;
                await showMission("PROTOCOL ABORTED!", "Eavesdropper detected! The key is discarded. The secret remains safe.");
            } else {
                UI.finalKeyDisplay.style.opacity = 1;
                bobKey.forEach(bit => displayKey(UI.finalKey, bit));
                await showMission("PROTOCOL COMPLETE", "A secure, secret key has been successfully established.");
            }
            
            simulationRunning = false;
            UI.startBtn.disabled = false;
            UI.startBtn.textContent = "RE-INITIATE PROTOCOL";
        }

        // --- ANIMATION & CAMERA ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            photons.forEach(p => {
                p.core.rotation.y += delta * 2;
                p.shell.rotation.x -= delta;
            });
            if (eve.group.visible) {
                 eve.eye.material.emissiveIntensity = 2 + Math.sin(clock.getElapsedTime() * 5);
            }
            renderer.render(scene, camera);
        }

        function animatePhotons() {
            return new Promise(resolve => {
                const timeline = gsap.timeline({ onComplete: resolve });
                photons.forEach((p, i) => {
                    const duration = 3;
                    timeline.to(p.group.position, {
                        x: patient.group.position.x,
                        duration: duration,
                        ease: "none",
                        onUpdate: function() {
                            if (eve.group.visible && !p.intercepted && this.progress() > 0.45 && this.progress() < 0.55) {
                                p.intercepted = true;
                                
                                // Eve's interception VFX
                                const beamGeo = new THREE.CylinderGeometry(0.1, 1, 15, 8);
                                const beamMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.7 });
                                const beam = new THREE.Mesh(beamGeo, beamMat);
                                beam.position.copy(eve.group.position).y += 15;
                                beam.lookAt(p.group.position);
                                scene.add(beam);
                                gsap.to(beam.scale, { x:0, y:0, z:0, duration: 0.5, delay: 0.2, onComplete: () => scene.remove(beam) });

                                // Alter photon state
                                const eveBasis = ['+', 'x'][Math.floor(Math.random() * 2)];
                                if (p.basis !== eveBasis) p.bit = Math.round(Math.random());
                                p.basis = eveBasis;
                                
                                // Visual feedback
                                const originalColor = p.core.material.color.clone();
                                gsap.to(p.core.material.color, { r:1, g:0, b:0, duration: 0.1, yoyo: true, repeat: 1, onComplete: () => p.core.material.color.copy(originalColor)});
                            }
                        }
                    }, i * 0.2); // Stagger the start times
                });
            });
        }

        function moveCamera(targetPos, distance) {
            gsap.to(camera.position, {
                x: targetPos.x,
                y: targetPos.y + 20,
                z: targetPos.z + distance,
                duration: 1,
                ease: "power2.inOut",
                onUpdate: () => camera.lookAt(targetPos)
            });
        }

        function resetCamera() {
            gsap.to(camera.position, {
                x: 0, y: 40, z: 180,
                duration: 1,
                ease: "power2.inOut",
                onUpdate: () => camera.lookAt(0, 0, 0)
            });
        }

        // --- UI & HELPERS ---
        function resetUI() {
            [UI.aliceData, UI.bobData, UI.finalKey].forEach(el => el.innerHTML = '');
            UI.errorDisplay.style.display = 'none';
            UI.finalKeyDisplay.style.opacity = 0;
            photons.forEach(p => scene.remove(p.group));
            photons = [];
            gsap.to(UI.missionObjective, { x: '-150%', opacity: 0, duration: 0.5 });
        }
        
        function showMission(title, description) {
            return new Promise(resolve => {
                gsap.to(UI.missionObjective, { x: '-150%', opacity: 0, duration: 0.5, onComplete: () => {
                    UI.stepTitle.textContent = title;
                    UI.stepDescription.textContent = description;
                    gsap.to(UI.missionObjective, { x: '0%', opacity: 1, duration: 0.5, ease: "power2.out", onComplete: () => setTimeout(resolve, 2000) });
                }});
            });
        }
        
        function displayData(element, bit, basis) {
            const div = document.createElement('div');
            div.className = 'data-bit';
            div.innerHTML = `<span>${bit}</span><span class="basis-symbol" style="color:${basis === '+' ? '#00FFFF' : '#FF00FF'}">${basis}</span>`;
            element.appendChild(div);
        }
        
        function displayKey(element, bit) {
            const div = document.createElement('div');
            div.className = 'w-8 h-8 flex items-center justify-center m-1 bg-green-900/80 border border-green-500 rounded text-white font-bold';
            div.textContent = bit;
            element.appendChild(div);
        }

        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
